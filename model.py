import random
from pubsub import *
from log import Log

# the events generated by a Model instance 
modelevents = ["change", "init", "moveupdate"]

# initialise the logger
log = Log()

# An instance of this class represents the model of the game, and contains the "bare" game data and logic
# the class inherits the Publisher class to allow observation of events by game view(s)
class Model(Publisher):
    def __init__(self):
        self.size = 0
        self.numStates = 0
        self.m = []
        self.moves = 0
        self.replaced = 0
        Publisher.__init__(self, modelevents)

    # starts a new game (called from the controller)
    # - size: the size of the board (which is always square and hase size by size tiles)
    # - numStates: the number of different values ('colors') each cell of the board may contain
    def new(self, size, numStates):
        self.size = size
        self.numStates = numStates
        self.moves = 0
        self.replaced = 0
        self.init()

    # (re)initializes the game (called from the controller)
    def init(self):
        Publisher.dispatch(self, "init", (self.size, self.numStates))
        self.m = []
        for r in range(1, self.size+1):
            row = []
            for c in range(1, self.size+1):
                v = random.randint(0,self.numStates-1)
                row.append(v)
                Publisher.dispatch(self, "change", (r, c, v))
            self.m.append(row)

    # performs the flood operation (called from the controller when the user clicks on a tile)
    # - replacementValue: the value to flood the game matrix with 
    def flood(self, replacementValue):
        startnode = (1, 1)
        targetValue = self.getValue(startnode)
        self.floodfill(startnode, targetValue, replacementValue)
        if self.replaced>0:
             self.moves += 1
             Publisher.dispatch(self, "moveupdate", (self.moves, self.replaced))

    def getSize(self):
        return self.size

    def getValue(self, node):
        if (self.size>0 and self.isValidNode(node)):
            return self.m[node[0]-1][node[1]-1]
        else:
            return -1

    def setValue(self, node, v):
        if (self.size>0 and self.isValidNode(node)):
            log.trace("setValue: (node,v):" + str((node, v)))
            self.m[node[0]-1][node[1]-1] = v
            Publisher.dispatch(self, "change", (node[0], node[1], v))

    # implements the actual flood fill algorithm ("forest fire"). 
    # - node: a tuple (r,c) denoting the row and column number of the cell to start the floodfill at (always (1,1)) 
    # - targetValue: the target value that is to be replaced with the replacement value 
    # - replacementValue: the replacement value to flood the game matrix with 
    def floodfill(self, node, targetValue, replacementValue):
        log.trace("Model.floodfill(node, targetValue, replacementValue):" + str((node, targetValue, replacementValue)))
        self.replaced = 0
        if (len(node)==2):
            r = node[0]
            c = node[1]
            if self.replace(node, targetValue, replacementValue):
                queue = list()
                queue.append(node)   
                while len(queue)>0:
                    n = queue[0]
                    del queue[0]
                    directions = [(n[0]-1, n[1]), (n[0], n[1]-1), (n[0]+1, n[1]), (n[0], n[1]+1)]
                    for d in directions: 
                        if self.replace(d, targetValue, replacementValue): queue.append(d)  

    # validates and performs the actual replacing target value with replacement value of the value in the speficied node
    # if the operation is not valid (node is out of bounds, cell does not contain target value), the function returns False,
    # otherwise, the value is replaced and the function returns True
    # - node: see floodfill 
    # - targetValue: see floodfill
    # - replacementValue: see floodfill
    def replace(self, node, targetValue, replacementValue):
        if (self.isValidNode(node)):
            if targetValue>=0 and targetValue != replacementValue:
                log.trace("Model.replace(node, targetValue, replacementValue):" + str((node, targetValue, replacementValue)))
                if self.getValue(node) == targetValue:
                    self.setValue(node, replacementValue)
                    self.replaced += 1
                    return True
        return False

    def isValidNode(self, node):
        return (len(node)==2 and node[0]>0 and node[0]<=self.size and node[1]>0 and node[1]<=self.size)                            


